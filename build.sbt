import Dependencies._
import Util._
import com.typesafe.tools.mima.core._, ProblemFilters._

def baseVersion = "1.0.0-SNAPSHOT"
def internalPath   = file("internal")

def commonSettings: Seq[Setting[_]] = Seq(
  scalaVersion := scala212,
  // publishArtifact in packageDoc := false,
  resolvers += Resolver.typesafeIvyRepo("releases"),
  resolvers += Resolver.sonatypeRepo("snapshots"),
  resolvers += Resolver.mavenLocal,
  // concurrentRestrictions in Global += Util.testExclusiveRestriction,
  testOptions += Tests.Argument(TestFrameworks.ScalaCheck, "-w", "1"),
  javacOptions in compile ++= Seq("-Xlint", "-Xlint:-serial"),
  crossScalaVersions := Seq(scala211, scala212),
  scalacOptions := {
    val old = scalacOptions.value
    scalaVersion.value match {
      case sv if sv.startsWith("2.10") => old diff List("-Xfuture", "-Ywarn-unused", "-Ywarn-unused-import")
      case sv if sv.startsWith("2.11") => old ++ List("-Ywarn-unused", "-Ywarn-unused-import")
      case _                           => old ++ List("-Ywarn-unused", "-Ywarn-unused-import", "-YdisableFlatCpCaching")
    }
  },
  scalacOptions in console in Compile -= "-Ywarn-unused-import",
  scalacOptions in console in Test    -= "-Ywarn-unused-import",
  publishArtifact in Compile := true,
  publishArtifact in Test := false
)

val mimaSettings = Def settings (
  mimaPreviousArtifacts := Set(organization.value % moduleName.value % "1.0.0-M28"
    cross (if (crossPaths.value) CrossVersion.binary else CrossVersion.disabled)
  )
)

lazy val utilRoot: Project = (project in file(".")).
  aggregate(
    utilInterface, utilControl, utilPosition,
    utilLogging, utilRelation, utilCache, utilTracking, utilTesting,
    utilScripted
  ).
  settings(
    inThisBuild(Seq(
      git.baseVersion := baseVersion,
      version := {
        val v = version.value
        if (v contains "SNAPSHOT") git.baseVersion.value
        else v
      },
      bintrayPackage := "util",
      homepage := Some(url("https://github.com/sbt/util")),
      description := "Util module for sbt",
      scmInfo := Some(ScmInfo(url("https://github.com/sbt/util"), "git@github.com:sbt/util.git"))
    )),
    commonSettings,
    name := "Util Root",
    publish := {},
    publishLocal := {},
    publishArtifact in Compile := false,
    publishArtifact in Test := false,
    publishArtifact := false,
    customCommands
  )

// defines Java structures used across Scala versions, such as the API structures and relationships extracted by
//   the analysis compiler phases and passed back to sbt.  The API structures are defined in a simple
//   format from which Java sources are generated by the datatype generator Projproject
lazy val utilInterface = (project in internalPath / "util-interface").
  settings(
    commonSettings,
    javaOnlySettings,
    name := "Util Interface",
    exportJars := true,
    mimaSettings,
  )

lazy val utilControl = (project in internalPath / "util-control").
  settings(
    commonSettings,
    name := "Util Control",
    mimaSettings,
  )

val utilPosition = (project in file("internal") / "util-position").settings(
  commonSettings,
  name := "Util Position",
  mimaSettings,
)

// logging
lazy val utilLogging = (project in internalPath / "util-logging").
  enablePlugins(ContrabandPlugin, JsonCodecPlugin).
  dependsOn(utilInterface, utilTesting % Test).
  settings(
    commonSettings,
    crossScalaVersions := Seq(scala210, scala211, scala212),
    name := "Util Logging",
    libraryDependencies ++= Seq(jline, log4jApi, log4jCore, disruptor, sjsonnewScalaJson.value, scalaReflect.value),
    sourceManaged in (Compile, generateContrabands) := baseDirectory.value / "src" / "main" / "contraband-scala",
    contrabandFormatsForType in generateContrabands in Compile := { tpe =>
      val old = (contrabandFormatsForType in generateContrabands in Compile).value
      val name = tpe.removeTypeParameters.name
      if (name == "Throwable") Nil
      else old(tpe)
    },
    mimaSettings,
    mimaBinaryIssueFilters ++= Seq(
      // abstract method SuccessEventFormat()sjsonnew.JsonFormat in trait sbt.internal.util.codec.SuccessEventFormats is inherited by class JsonProtocol in current version.
      // I think this is a false positive: https://github.com/typesafehub/migration-manager/issues/187
      ProblemFilters.exclude[InheritedNewAbstractMethodProblem]("sbt.internal.util.codec.SuccessEventFormats.SuccessEventFormat")
    )
  )

// Relation
lazy val utilRelation = (project in internalPath / "util-relation").
  dependsOn(utilTesting % Test).
  settings(
    commonSettings,
    name := "Util Relation",
    mimaSettings,
  )

// Persisted caching based on sjson-new
lazy val utilCache = (project in file("util-cache")).
  dependsOn(utilTesting % Test).
  settings(
    commonSettings,
    name := "Util Cache",
    libraryDependencies ++= Seq(sjsonnewScalaJson.value, sjsonnewMurmurhash.value, scalaReflect.value),
    mimaSettings,
  ).
  configure(addSbtIO)

// Builds on cache to provide caching for filesystem-related operations
lazy val utilTracking = (project in file("util-tracking")).
  dependsOn(utilCache, utilTesting % Test).
  settings(
    commonSettings,
    name := "Util Tracking",
    mimaSettings,
  ).
  configure(addSbtIO)

// Internal utility for testing
lazy val utilTesting = (project in internalPath / "util-testing").
  settings(
    commonSettings,
    crossScalaVersions := Seq(scala210, scala211, scala212),
    name := "Util Testing",
    libraryDependencies ++= Seq(scalaCheck, scalatest),
    mimaSettings,
  ).
  configure(addSbtIO)

lazy val utilScripted = (project in internalPath / "util-scripted").
  dependsOn(utilLogging, utilInterface).
  settings(
    commonSettings,
    name := "Util Scripted",
    libraryDependencies ++= {
      scalaVersion.value match {
        case sv if sv startsWith "2.11" => Seq(parserCombinator211)
        case sv if sv startsWith "2.12" => Seq(parserCombinator211)
        case _ => Seq()
      }
    },
    mimaSettings,
  ).
  configure(addSbtIO)

def customCommands: Seq[Setting[_]] = Seq(
  commands += Command.command("release") { state =>
    // "clean" ::
    "+compile" ::
    "+publishSigned" ::
    "reload" ::
    state
  }
)
