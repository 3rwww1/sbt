/*
 * sbt
 * Copyright 2011 - 2018, Lightbend, Inc.
 * Copyright 2008 - 2010, Mark Harrah
 * Licensed under Apache License 2.0 (see LICENSE)
 */

package sbt.internal

import java.io.File
import java.net.URLClassLoader
import java.util.concurrent.ConcurrentHashMap

import sbt.internal.inc.classpath._
import sbt.io.IO

import scala.collection.JavaConverters._
import scala.collection.mutable.ListBuffer

private[sbt] class LayeredClassLoaderImpl(
    classpath: Seq[File],
    parent: ClassLoader,
    override protected val resources: Map[String, String],
    tempDir: File,
) extends URLClassLoader(classpath.toArray.map(_.toURI.toURL), parent)
    with RawResources
    with NativeCopyLoader
    with AutoCloseable {
  private[this] val nativeLibs = new java.util.HashSet[File]().asScala
  override protected val config = new NativeCopyConfig(
    tempDir,
    classpath,
    IO.parseClasspath(System.getProperty("java.library.path", ""))
  )
  override def findLibrary(name: String): String = {
    super.findLibrary(name) match {
      case null => null
      case l =>
        nativeLibs += new File(l)
        l
    }
  }

  private[this] val loaded = new ConcurrentHashMap[String, Class[_]]
  private[this] val classLocks = new ConcurrentHashMap[String, AnyRef]()
  /*
   * Override findClass to both memoize its result and look down the class hierarchy to attempt to
   * load a missing class from a descendant loader. If we didn't cache the loaded classes,
   * then it would be possible for this class loader to load a different version of the class than
   * the descendant, which would likely cause a crash. The search for the class in the descendants
   * allows java reflection to work in cases where the class to load via reflection is not directly
   * visible to the class that is attempting to load it.
   */
  override def findClass(name: String): Class[_] = loaded.get(name) match {
    case null =>
      val newLock = new AnyRef
      val lock = classLocks.putIfAbsent(name, newLock) match {
        case null => newLock
        case l    => l
      }
      lock.synchronized {
        try {
          val clazz = super.findClass(name)
          loaded.putIfAbsent(name, clazz) match {
            case null => clazz
            case c    => c
          }
        } catch {
          case e: ClassNotFoundException =>
            /*
             * If new threads are spawned, they inherit the context class loader of the parent
             * This means that if a test or run task spawns background threads to do work, then the
             * same context class loader is available on all of the background threads. In the test
             * and run tasks, we temporarily set the context class loader of the main sbt thread to
             * be the classloader generated by ClassLoaders.getLayers. This creates an environment
             * that looks somewhat like a forked jvm with the app classloader set to be the
             * generated class loader. If the test or run main changes the thread context class
             * loader, this search might fail even if it would have passed on the initial entry
             * into the method. Applications generally only modify the context classloader if they
             * are manually loading classes. It's likely that if an application generated
             * ClassLoader needs access to the classes in the sbt classpath, then it would be using
             * the original context class loader as the parent of the new context class loader
             * anyway.
             *
             * If we wanted to make this change permanent so that the user could not
             * override the global context classloader, we would possibly need to intercept the
             * classloading of java.lang.Thread itself to return a custom Thread class that mirrors
             * the java.lang.Thread api, but stores the context class loader in a custom field.
             *
             */
            var currentLoader: ClassLoader = Thread.currentThread.getContextClassLoader
            val loaders = new ListBuffer[LayeredClassLoader]
            do {
              currentLoader match {
                case cl: LayeredClassLoader if cl != this => loaders.prepend(cl)
                case _                                    =>
              }
              currentLoader = currentLoader.getParent
            } while (currentLoader != null && currentLoader != this)
            if (currentLoader == this && loaders.nonEmpty) {
              val resourceName = name.replace('.', '/').concat(".class")
              loaders
                .collectFirst {
                  case l if l.findResource(resourceName) != null => l.findClass(name)
                }
                .getOrElse(throw e)
            } else throw e
        }
      }
    case c => c
  }
  override def close(): Unit = nativeLibs.foreach(NativeLibs.delete)
  override def toString: String = s"""LayeredClassLoader(
  |  classpath =
  |    ${classpath mkString "\n    "}
  |  parent =
  |    ${parent.toString.linesIterator.mkString("\n    ")}
  |)""".stripMargin
}

private[internal] class ResourceLoaderImpl(
    classpath: Seq[File],
    parent: ClassLoader,
    resources: Map[String, String]
) extends LayeredClassLoader(classpath, parent, resources, new File("/dev/null")) {
  override def findClass(name: String): Class[_] = throw new ClassNotFoundException(name)
  override def loadClass(name: String, resolve: Boolean): Class[_] = {
    val clazz = parent.loadClass(name)
    if (resolve) resolveClass(clazz)
    clazz
  }
  override def toString: String = "ResourceLoader"
}

private[internal] object NativeLibs {
  private[this] val nativeLibs = new java.util.HashSet[File].asScala
  ShutdownHooks.add(() => {
    nativeLibs.foreach(IO.delete)
    IO.deleteIfEmpty(nativeLibs.map(_.getParentFile).toSet)
    nativeLibs.clear()
  })
  def addNativeLib(lib: String): Unit = {
    nativeLibs.add(new File(lib))
    ()
  }
  def delete(file: File): Unit = {
    nativeLibs.remove(file)
    file.delete()
    ()
  }
}
